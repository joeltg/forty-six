package types

import (
	"encoding/binary"
	"fmt"
	"strings"

	badger "github.com/dgraph-io/badger"
	proto "github.com/golang/protobuf/proto"
	cid "github.com/ipfs/go-cid"
	ld "github.com/piprate/json-gold/ld"
)

// Value needs to satisfy the ld.Node interface, which means implementing
// GetValue() => string and Equal(ld.Node) => bool

// GetValue serializes the value to a string.
func (value *Value) GetValue() string {
	if b, isBlank := value.Node.(*Value_Blank); isBlank {
		c, _ := cid.Cast(b.Blank.Cid)
		return fmt.Sprintf("<ul:/ipfs/%s#%s>", c.String(), b.Blank.Id)
	} else if i, isIri := value.Node.(*Value_Iri); isIri {
		return fmt.Sprintf("<%s>", i.Iri)
	} else if l, isLiteral := value.Node.(*Value_Literal); isLiteral {
		v, d, l := l.Literal.Value, l.Literal.Datatype, l.Literal.Language
		escaped := escape(v)
		if d == ld.RDFLangString {
			return fmt.Sprintf("\"%s\"@%s", escaped, l)
		} else if d != ld.XSDString {
			return fmt.Sprintf("\"%s\"^^<%s>", escaped, d)
		} else {
			return fmt.Sprintf("\"%s\"", escaped)
		}
	} else {
		return ""
	}
}

func escape(str string) string {
	str = strings.Replace(str, "\\", "\\\\", -1)
	str = strings.Replace(str, "\"", "\\\"", -1)
	str = strings.Replace(str, "\n", "\\n", -1)
	str = strings.Replace(str, "\r", "\\r", -1)
	str = strings.Replace(str, "\t", "\\t", -1)
	return str
}

// Equal tests for equality between two ld.Nodes
func (value *Value) Equal(node ld.Node) bool {
	return value.GetValue() == node.GetValue()
}

// GetID satisfies the HasValue interface for index values by returning the index Id.
// The Index struct is generated by protobuf.
func (index *Index) GetID(_ interface{}) uint64 {
	return index.GetId()
}

// Increment the counter at the given position
func (index *Index) Increment(place uint8) {
	if place == 0 {
		index.Subject++
	} else if place == 1 {
		index.Predicate++
	} else if place == 2 {
		index.Object++
	}
}

// Get the counter at the given position
func (index *Index) Get(place uint8) uint64 {
	if place == 0 {
		return index.GetSubject()
	} else if place == 1 {
		return index.GetPredicate()
	} else if place == 2 {
		return index.GetObject()
	} else {
		return 0
	}
}

// An IndexMap associates marshalled string values with the
// Index structs that have already been read from the database.
// The Index struct is generated by protobuf.
type IndexMap map[string]*Index

// Commit writes the contents of the index map to badger
func (indices IndexMap) Commit(txn *badger.Txn) (err error) {
	var value []byte
	for v, index := range indices {
		key := AssembleKey(IndexPrefix, []byte(v), nil, nil)
		if value, err = proto.Marshal(index); err != nil {
			return
		} else if err = txn.Set(key, value); err != nil {
			return
		}
	}
	return
}

// Get memoizes database lookup for RDF nodes.
func (indices IndexMap) Get(node ld.Node, txn *badger.Txn) (*Index, error) {
	value := NodeToValue(cid.Undef, node).GetValue()
	if index, has := indices[value]; has {
		return index, nil
	}

	key := AssembleKey(IndexPrefix, []byte(value), nil, nil)
	if item, err := txn.Get(key); err != nil {
		return nil, err
	} else if indexValue, err := item.ValueCopy(nil); err != nil {
		return nil, err
	} else {
		indices[value] = &Index{}
		if err = proto.Unmarshal(indexValue, indices[value]); err != nil {
			return nil, err
		}
		return indices[value], nil
	}
}

// NodeToValue parses a cid.Cid and an ld.Node into a Value struct.
func NodeToValue(origin cid.Cid, node ld.Node) *Value {
	value := &Value{}
	if iri, isIri := node.(*ld.IRI); isIri {
		value.Node = &Value_Iri{Iri: iri.Value}
	} else if literal, isLiteral := node.(*ld.Literal); isLiteral {
		value.Node = &Value_Literal{
			Literal: &Literal{
				Value:    literal.Value,
				Language: literal.Language,
				Datatype: literal.Datatype,
			},
		}
	} else if blank, isBlank := node.(*ld.BlankNode); isBlank {
		value.Node = &Value_Blank{
			Blank: &Blank{
				Cid: origin.Bytes(),
				Id:  blank.Attribute,
			},
		}
	}
	return value
}

// A ValueMap associates uint64 ids with a value.
// The Value struct is generated by protobuf.
type ValueMap map[uint64]*Value

// InsertNode generates a new uint64 id relative to a counter
func (values ValueMap) InsertNode(value *Value, counter uint64) uint64 {
	id := counter + uint64(len(values))
	values[id] = value
	return id
}

// Commit writes the contents of the value map to badger
func (values ValueMap) Commit(txn *badger.Txn) (err error) {
	var value []byte
	for id, v := range values {
		if value, err = proto.Marshal(v); err != nil {
			return err
		}

		key := make([]byte, 9)
		key[0] = ValuePrefix
		binary.BigEndian.PutUint64(key[1:], id)

		if err = txn.Set(key, value); err != nil {
			return
		}
	}
	return
}

// AssembleKey will look at the prefix byte to determine
// how many of the elements {abc} to pack into the key.
func AssembleKey(prefix byte, a, b, c []byte) []byte {
	A, B, C := len(a), len(b), len(c)
	key := make([]byte, 1+A+B+C)
	key[0] = prefix
	if A > 0 {
		copy(key[1:1+A], a)
		if B > 0 {
			copy(key[1+A:1+A+B], b)
			if C > 0 {
				copy(key[1+A+B:1+A+B+C], c)
			}
		}
	}
	return key
}

// PrintSources pretty-prints a slice of sources on a single line.
func PrintSources(sources []*Source) string {
	s := "[ "
	for i, source := range sources {
		c, _ := cid.Parse(source.Cid)
		if i > 0 {
			s += " | "
		}
		s += fmt.Sprintf("%s#%s/%d", c.String(), source.Graph, source.Index)
	}
	return s + " ]"
}
