package main

import (
	"encoding/binary"
	"fmt"
	"log"
	"strings"

	badger "github.com/dgraph-io/badger"
	proto "github.com/golang/protobuf/proto"
	cid "github.com/ipfs/go-cid"
	ld "github.com/piprate/json-gold/ld"
)

// HasValue is either a string representing a variable reference,
// or an Index representing an absolute value from the database
type HasValue interface {
	GetValue(assignmentMap *AssignmentMap) uint64
}

// A Variable is a string with a GetValue method
type Variable string

// GetValue satisfies the HasValue interface for variables by looking up the
// variable's value in the assignmentMap.
func (variable Variable) GetValue(assignmentMap *AssignmentMap) uint64 {
	if assignmentMap != nil {
		id := string(variable)
		if assignment, has := assignmentMap.Index[id]; has {
			return binary.BigEndian.Uint64(assignment.Value[:])
		}
	}
	return 0
}

// GetValue satisfies the HasValue interface for index values by returning the index Id.
// The Index struct is generated by protobuf.
func (index *Index) GetValue(_ *AssignmentMap) uint64 {
	return index.GetId()
}

// Increment the counter at the given position
func (index *Index) Increment(place uint8) {
	if place == 0 {
		index.Subject++
	} else if place == 1 {
		index.Predicate++
	} else if place == 2 {
		index.Object++
	}
}

// Get the counter at the given position
func (index *Index) Get(place uint8) uint64 {
	if place == 0 {
		return index.GetSubject()
	} else if place == 1 {
		return index.GetPredicate()
	} else if place == 2 {
		return index.GetObject()
	} else {
		return 0
	}
}

// An IndexMap associates marshalled string values with the
// Index structs that have already been read from the database.
// The Index struct is generated by protobuf.
type IndexMap map[string]*Index

// GetIndex memoizes database lookup for RDF nodes.
func (indexMap IndexMap) GetIndex(node ld.Node, txn *badger.Txn) (*Index, error) {
	value := marshalNode(nil, node)
	if index, hasIndex := indexMap[value]; hasIndex {
		return index, nil
	}

	indexKey := make([]byte, 1, 1+len(value))
	indexKey[0] = IndexPrefix
	indexKey = append(indexKey, []byte(value)...)
	item, err := txn.Get(indexKey)
	if err != nil {
		return nil, err
	}
	indexValue, err := item.ValueCopy(nil)
	if err != nil {
		return nil, err
	}
	index := &Index{}
	err = proto.Unmarshal(indexValue, index)
	if err != nil {
		return nil, err
	}
	indexMap[value] = index
	return index, nil
}

// A ValueMap associates uint64 ids with a value.
// The Value struct is generated by protobuf.
type ValueMap map[uint64]*Value

func nodeToValue(node ld.Node, origin *cid.Cid) *Value {
	if iri, isIri := node.(*ld.IRI); isIri {
		return &Value{Node: &Value_Iri{Iri: iri.Value}}
	} else if literal, isLiteral := node.(*ld.Literal); isLiteral {
		return &Value{
			Node: &Value_Literal{
				Literal: &Literal{
					Value:    literal.Value,
					Language: literal.Language,
					Datatype: literal.Datatype,
				},
			},
		}
	} else if blank, isBlank := node.(*ld.BlankNode); isBlank {
		return &Value{
			Node: &Value_Blank{
				Blank: &Blank{
					Cid: origin.Bytes(),
					Id:  blank.Attribute,
				},
			},
		}
	}
	return nil
}

func valueToNode(value *Value) (ld.Node, error) {
	if blank, isBlank := value.Node.(*Value_Blank); isBlank {
		c, err := cid.Cast(blank.Blank.Cid)
		if err != nil {
			return nil, err
		}
		iri := fmt.Sprintf("<dweb:/ipfs/%s#%s>", c.String(), blank.Blank.Id)
		return &ld.IRI{Value: iri}, nil
	} else if iri, isIri := value.Node.(*Value_Iri); isIri {
		return &ld.IRI{Value: iri.Iri}, nil
	} else if literal, isLiteral := value.Node.(*Value_Literal); isLiteral {
		return &ld.Literal{
			Value:    literal.Literal.Value,
			Datatype: literal.Literal.Datatype,
			Language: literal.Literal.Language,
		}, nil
	}
	return nil, nil
}

func marshalLiteral(value, datatype, language string) string {
	result := escape(value)
	if datatype == ld.RDFLangString {
		result += "@" + language
	} else if datatype != ld.XSDString {
		result += "^^<" + escape(datatype) + ">"
	}
	return result
}

func marshalBlank(origin *cid.Cid, id string) string {
	if origin == nil {
		return ""
	}
	return fmt.Sprintf("<dweb:/ipfs/%s#%s>", origin.String(), id)
}

func marshalNode(origin *cid.Cid, node ld.Node) string {
	if iri, isIRI := node.(*ld.IRI); isIRI {
		return "<" + escape(iri.Value) + ">"
	} else if blank, isBlank := node.(*ld.BlankNode); isBlank {
		return marshalBlank(origin, blank.Attribute)
	} else if literal, isLiteral := node.(*ld.Literal); isLiteral {
		return marshalLiteral(literal.Value, literal.Datatype, literal.Language)
	}
	return ""
}

func getValueFromKey(prefix byte, key []byte) []byte {
	if _, has := triplePrefixMap[prefix]; has {
		return key[17:25]
	} else if _, has := majorPrefixMap[prefix]; has {
		return key[9:17]
	} else if _, has := minorPrefixMap[prefix]; has {
		return key[9:17]
	} else {
		return key[1:9] // Should never happen?
	}
}

// assembleKey will look at the prefix byte to determine
// how many of the elements {abc} to pack into the key.
// This is important because we ofter deliberately "short"
// a key so to make an iteration prefix.
func assembleKey(prefix byte, a, b, c []byte) []byte {
	A, B, C := len(a), len(b), len(c)
	keySize := 1 + A + B + C
	key := make([]byte, keySize)
	key[0] = prefix
	if A > 0 {
		copy(key[1:1+A], a)
		if B > 0 {
			copy(key[1+A:1+A+B], b)
			if C > 0 {
				copy(key[1+A+B:1+A+B+C], c)
			}
		}
	}
	return key
}

func permuteMajor(permutation uint8, s, p, o []byte) ([]byte, []byte, []byte) {
	if permutation == 0 {
		return s, p, o
	} else if permutation == 1 {
		return p, o, s
	} else if permutation == 2 {
		return o, s, p
	}
	log.Fatalln("Invalid major permutation")
	return nil, nil, nil
}

func permuteMinor(permutation uint8, s, p, o []byte) ([]byte, []byte, []byte) {
	if permutation == 0 {
		return s, o, p
	} else if permutation == 1 {
		return p, s, o
	} else if permutation == 2 {
		return o, p, s
	}
	log.Fatalln("Invalid minor permutation")
	return nil, nil, nil
}

func escape(str string) string {
	str = strings.Replace(str, "\\", "\\\\", -1)
	str = strings.Replace(str, "\"", "\\\"", -1)
	str = strings.Replace(str, "\n", "\\n", -1)
	str = strings.Replace(str, "\r", "\\r", -1)
	str = strings.Replace(str, "\t", "\\t", -1)
	return str
}
